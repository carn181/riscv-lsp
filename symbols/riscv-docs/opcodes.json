{ "Opcodes": [
    {"name": "lr.d", "format": "lr.d       rd,rs1", "description": "load a 64-bit data from the address in rs1, places value in rd, and registers a reservation on the memory address.", "implementation": "x[rd] = LoadReserved64(M[x[rs1]])"},
    {"name": "sc.d", "format": "sc.d       rd,rs1,rs2", "description": "write a 64-bit data in rs2 to the address in rs1, provided a valid reservation still exists on that address.SC writes zero to rd on success or a nonzero code on failure.", "implementation": "x[rd] = StoreConditional64(M[x[rs1]], x[rs2])"},
    {"name": "amoswap.d", "format": "amoswap.d  rd,rs2,(rs1)", "description": "atomically load a 64-bit data value from the address in rs1, place the value into register rd, swap the loaded value and the original 64-bit value in rs2, then store the result back to the address in rs1.", "implementation": "x[rd] = AMO64(M[x[rs1]] SWAP x[rs2])"},
    {"name": "amoadd.d", "format": "amoadd.d   rd,rs2,(rs1)", "description": "atomically load a 64-bit data value from the address in rs1, place the value into register rd, apply add the loaded value and the original 64-bit value in rs2, then store the result back to the address in rs1.", "implementation": "x[rd] = AMO64(M[x[rs1]] + x[rs2])"},
    {"name": "amoxor.d", "format": "amoxor.d   rd,rs2,(rs1)", "description": "atomically load a 64-bit data value from the address in rs1, place the value into register rd, apply xor the loaded value and the original 64-bit value in rs2, then store the result back to the address in rs1.", "implementation": "x[rd] = AMO64(M[x[rs1]] ^ x[rs2])"},
    {"name": "amoand.d", "format": "amoand.d   rd,rs2,(rs1)", "description": "atomically load a 64-bit data value from the address in rs1, place the value into register rd, apply and the loaded value and the original 64-bit value in rs2, then store the result back to the address in rs1.", "implementation": "x[rd] = AMO64(M[x[rs1]] & x[rs2])"},
    {"name": "amoor.d", "format": "amoor.d    rd,rs2,(rs1)", "description": "atomically load a 64-bit data value from the address in rs1, place the value into register rd, apply or the loaded value and the original 64-bit value in rs2, then store the result back to the address in rs1.", "implementation": "x[rd] = AMO64(M[x[rs1]] | x[rs2])"},
    {"name": "amomin.d", "format": "amomin.d   rd,rs2,(rs1)", "description": "atomically load a 64-bit data value from the address in rs1, place the value into register rd, apply min the loaded value and the original 64-bit value in rs2, then store the result back to the address in rs1.", "implementation": "x[rd] = AMO64(M[x[rs1]] MIN x[rs2])"},
    {"name": "amomax.d", "format": "amomax.d   rd,rs2,(rs1)", "description": "atomically load a 64-bit data value from the address in rs1, place the value into register rd, apply max the loaded value and the original 64-bit value in rs2, then store the result back to the address in rs1.", "implementation": "x[rd] = AMO64(M[x[rs1]] MAX x[rs2])"},
    {"name": "amominu.d", "format": "amominu.d  rd,rs2,(rs1)", "description": "atomically load a 64-bit data value from the address in rs1, place the value into register rd, apply unsigned min the loaded value and the original 64-bit value in rs2, then store the result back to the address in rs1.", "implementation": "x[rd] = AMO64(M[x[rs1]] MINU x[rs2])"},
    {"name": "amomaxu.d", "format": "amomaxu.d  rd,rs2,(rs1)", "description": "atomically load a 64-bit data value from the address in rs1, place the value into register rd, apply unsigned max the loaded value and the original 64-bit value in rs2, then store the result back to the address in rs1.", "implementation": "x[rd] = AMO64(M[x[rs1]] MAXU x[rs2])"},
    {"name": "fcvt.l.d", "format": "fcvt.l.d   rd,rs1", "description": "", "implementation": "x[rd] = s64_{f64}(f[rs1])"},
    {"name": "fcvt.lu.d", "format": "fcvt.lu.d  rd,rs1", "description": "", "implementation": "x[rd] = u64_{f64}(f[rs1])"},
    {"name": "fmv.x.d", "format": "fmv.x.d    rd,rs1", "description": "", "implementation": "x[rd] = f[rs1][63:0]"},
    {"name": "fcvt.d.l", "format": "fcvt.d.l   rd,rs1", "description": "", "implementation": "f[rd] = f64_{s64}(x[rs1])"},
    {"name": "fcvt.d.lu", "format": "fcvt.d.lu  rd,rs1", "description": "", "implementation": "f[rd] = f64_{u64}(x[rs1])"},
    {"name": "fmv.d.x", "format": "fmv.d.x    rd,rs1", "description": "", "implementation": "f[rd] = x[rs1][63:0]"},
    {"name": "fcvt.l.s", "format": "fcvt.l.s   rd,rs1", "description": "", "implementation": "x[rd] = s64_{f32}(f[rs1])"},
    {"name": "fcvt.lu.s", "format": "fcvt.lu.s  rd,rs1", "description": "", "implementation": "x[rd] = u64_{f32}(f[rs1])"},
    {"name": "fcvt.s.l", "format": "fcvt.s.l   rd,rs1", "description": "", "implementation": "f[rd] = f32_{s64}(x[rs1])"},
    {"name": "fcvt.s.lu", "format": "fcvt.s.lu  rd,rs1", "description": "", "implementation": "f[rd] = f32_{u64}(x[rs1])"},
    {"name": "addiw", "format": "addiw      rd,rs1,imm", "description": "Adds the sign-extended 12-bit immediate to register rs1 and produces the proper sign-extension of a 32-bit result in rd.Overflows are ignored and the result is the low 32 bits of the result sign-extended to 64 bits.Note, ADDIW rd, rs1, 0 writes the sign-extension of the lower 32 bits of register rs1 into register rd (assembler pseudoinstruction SEXT.W).", "implementation": "x[rd] = sext((x[rs1] + sext(immediate))[31:0])"},
    {"name": "slliw", "format": "slliw      rd,rs1,shamt", "description": "Performs logical left shift on the 32-bit of value in register rs1 by the shift amount held in the lower 5 bits of the immediate.Encodings with $imm[5] neq 0$ are reserved.", "implementation": "x[rd] = sext((x[rs1] << shamt)[31:0])"},
    {"name": "srliw", "format": "srliw      rd,rs1,shamt", "description": "Performs logical right shift on the 32-bit of value in register rs1 by the shift amount held in the lower 5 bits of the immediate.Encodings with $imm[5] neq 0$ are reserved.", "implementation": "x[rd] = sext(x[rs1][31:0] >>u shamt)"},
    {"name": "sraiw", "format": "sraiw      rd,rs1,shamt", "description": "Performs arithmetic right shift on the 32-bit of value in register rs1 by the shift amount held in the lower 5 bits of the immediate.Encodings with $imm[5] neq 0$ are reserved.", "implementation": "x[rd] = sext(x[rs1][31:0] >>s shamt)"},
    {"name": "addw", "format": "addw       rd,rs1,rs2", "description": "Adds the 32-bit of registers rs1 and 32-bit of register rs2 and stores the result in rd.Arithmetic overflow is ignored and the low 32-bits of the result is sign-extended to 64-bits and written to the destination register.", "implementation": "x[rd] = sext((x[rs1] + x[rs2])[31:0])"},
    {"name": "subw", "format": "subw       rd,rs1,rs2", "description": "Subtract the 32-bit of registers rs1 and 32-bit of register rs2 and stores the result in rd.Arithmetic overflow is ignored and the low 32-bits of the result is sign-extended to 64-bits and written to the destination register.", "implementation": "x[rd] = sext((x[rs1] - x[rs2])[31:0])"},
    {"name": "sllw", "format": "sllw       rd,rs1,rs2", "description": "Performs logical left shift on the low 32-bits value in register rs1 by the shift amount held in the lower 5 bits of register rs2 and produce 32-bit results and written to the destination register rd.", "implementation": "x[rd] = sext((x[rs1] << x[rs2][4:0])[31:0])"},
    {"name": "srlw", "format": "srlw       rd,rs1,rs2", "description": "Performs logical right shift on the low 32-bits value in register rs1 by the shift amount held in the lower 5 bits of register rs2 and produce 32-bit results and written to the destination register rd.", "implementation": "x[rd] = sext(x[rs1][31:0] >>u x[rs2][4:0])"},
    {"name": "sraw", "format": "sraw       rd,rs1,rs2", "description": "Performs arithmetic right shift on the low 32-bits value in register rs1 by the shift amount held in the lower 5 bits of register rs2 and produce 32-bit results and written to the destination register rd.", "implementation": "x[rd] = sext(x[rs1][31:0] >>s x[rs2][4:0])"},
    {"name": "lwu", "format": "lwu        rd,offset(rs1)", "description": "Loads a 32-bit value from memory and zero-extends this to 64 bits before storing it in register rd.", "implementation": "x[rd] = M[x[rs1] + sext(offset)][31:0]"},
    {"name": "ld", "format": "ld         rd,offset(rs1)", "description": "Loads a 64-bit value from memory into register rd for RV64I.", "implementation": "x[rd] = M[x[rs1] + sext(offset)][63:0]"},
    {"name": "sd", "format": "sd         rs2,offset(rs1)", "description": "Store 64-bit, values from register rs2 to memory.", "implementation": "M[x[rs1] + sext(offset)] = x[rs2][63:0]"},
    {"name": "mulw", "format": "mulw       rd,rs1,rs2", "description": "", "implementation": "x[rd] = sext((x[rs1] \u00d7 x[rs2])[31:0])"},
    {"name": "divw", "format": "divw       rd,rs1,rs2", "description": "perform an 32 bits by 32 bits signed integer division of rs1 by rs2.", "implementation": "x[rd] = sext(x[rs1][31:0] /s x[rs2][31:0]"},
    {"name": "divuw", "format": "divuw      rd,rs1,rs2", "description": "perform an 32 bits by 32 bits unsigned integer division of rs1 by rs2.", "implementation": "x[rd] = sext(x[rs1][31:0] /u x[rs2][31:0])"},
    {"name": "remw", "format": "remw       rd,rs1,rs2", "description": "perform an 32 bits by 32 bits signed integer reminder of rs1 by rs2.", "implementation": "x[rd] = sext(x[rs1][31:0] %s x[rs2][31:0])"},
    {"name": "remuw", "format": "remuw      rd,rs1,rs2", "description": "perform an 32 bits by 32 bits unsigned integer reminder of rs1 by rs2.", "implementation": "x[rd] = sext(x[rs1][31:0] %u x[rs2][31:0])"},
    {"name":"lr.w", "format":"lr.w       rd,rs1", "description":"load a word from the address in rs1, places the sign-extended value in rd, and registers a reservation on the memory address.", "implementation":"x[rd] = LoadReserved32(M[x[rs1]])"},
    {"name":"sc.w", "format":"sc.w       rd,rs1,rs2", "description":"write a word in rs2 to the address in rs1, provided a valid reservation still exists on that address.\nSC writes zero to rd on success or a nonzero code on failure.\nSC writes zero to rd on success or a nonzero code on failure"
    },
    {"name":"amoswap.w", "format":"amoswap.w  rd,rs2,(rs1)", "description":"atomically load a 32-bit signed data value from the address in rs1, place the value into register rd, swap the loaded value and the original 32-bit signed value in rs2, then store the result back to the address in rs1.", "implementation":"x[rd] = AMO32(M[x[rs1]] SWAP x[rs2])"
    },
    {"name":"amoadd.w", "format":"amoadd.w   rd,rs2,(rs1)", "description":"atomically load a 32-bit signed data value from the address in rs1, place the value into register rd, apply add the loaded value and the original 32-bit signed value in rs2, then store the result back to the address in rs1."
    },
    {"name":"amoxor.w", "format":"amoxor.w   rd,rs2,(rs1)", "description":"atomically load a 32-bit signed data value from the address in rs1, place the value into register rd, apply exclusive or the loaded value and the original 32-bit signed value in rs2, then store the result back to the address in rs1.", "implementation":"x[rd] = AMO32(M[x[rs1]] ^ x[rs2])"},
    {"name":"amoand.w", "format":"amoand.w   rd,rs2,(rs1)", "description":"atomically load a 32-bit signed data value from the address in rs1, place the value into register rd, apply and the loaded value and the original 32-bit signed value in rs2, then store the result back to the address in rs1.", "implementation":"x[rd] = AMO32(M[x[rs1]] & x[rs2])"},
    {"name":"amoor.w", "format":"amoor.w    rd,rs2,(rs1)", "description":"atomically load a 32-bit signed data value from the address in rs1, place the value into register rd, apply or the loaded value and the original 32-bit signed value in rs2, then store the result back to the address in rs1.", "implementation":"x[rd] = AMO32(M[x[rs1]] | x[rs2])"},
    {"name":"amomin.w", "format":"amomin.w   rd,rs2,(rs1)", "description":"atomically load a 32-bit signed data value from the address in rs1, place the value into register rd, apply min operator the loaded value and the original 32-bit signed value in rs2, then store the result back to the address in rs1.", "implementation":"x[rd] = AMO32(M[x[rs1]] MIN x[rs2])"},
    {"name":"amomax.w", "format":"amomax.w   rd,rs2,(rs1)", "description":"atomically load a 32-bit signed data value from the address in rs1, place the value into register rd, apply max operator the loaded value and the original 32-bit signed value in rs2, then store the result back to the address in rs1.", "implementation":"x[rd] = AMO32(M[x[rs1]] MAX x[rs2])"},
    {"name":"amominu.w", "format":"amominu.w  rd,rs2,(rs1)", "description":"atomically load a 32-bit unsigned data value from the address in rs1, place the value into register rd, apply unsigned min the loaded value and the original 32-bit unsigned value in rs2, then store the result back to the address in rs1.", "implementation":"x[rd] = AMO32(M[x[rs1]] MINU x[rs2])"},
    {"name":"amomaxu.w", "format":"amomaxu.w  rd,rs2,(rs1)", "description":"atomically load a 32-bit unsigned data value from the address in rs1, place the value into register rd, apply unsigned max the loaded value and the original 32-bit unsigned value in rs2, then store the result back to the address in rs1.", "implementation":"x[rd] = AMO32(M[x[rs1]] MAXU x[rs2])"
    },
    {"name": "c.addi4spn", "format": "c.addi4spn rd',uimm", "description": "Add a zero-extended non-zero immediate, scaled by 4, to the stack pointer, x2, and writes the result to rd'.This instruction is used to generate pointers to stack-allocated variables, and expands to addi rd', x2, nzuimm[9:2].", "implementation": "x[8+rd'] = x[2] + nzuimm", "expansion": "addi rd',x2,nzuimm"},
    {"name": "c.fld", "format": "c.fld      rd',uimm(rs1')", "description": "Load a double-precision floating-point value from memory into floating-point register rd'.It computes an effective address by adding the zero-extended offset, scaled by 8, to the base address in register rs1'.", "implementation": "f[8+rd'] = M[x[8+rs1'] + uimm][63:0]", "expansion": "fld rd',offset[7:3](rs1')"},
    {"name": "c.lw", "format": "c.lw       rd',uimm(rs1')", "description": "Load a 32-bit value from memory into register rd'. It computes an effective address by adding the zero-extended offset, scaled by 4, to the base address in register rs1'.", "implementation": "x[8+rd'] = sext(M[x[8+rs1'] + uimm][31:0])", "expansion": "lw rd',offset[6:2](rs1')"},
    {"name": "c.flw", "format": "c.flw      rd',uimm(rs1')", "description": "Load a single-precision floating-point value from memory into floating-point register rd'.It computes an effective address by adding the zero-extended offset, scaled by 4, to the base address in register rs1'.", "implementation": "f[8+rd'] = M[x[8+rs1'] + uimm][31:0]", "expansion": "lw rd',offset[6:2](rs1')"},
    {"name": "c.ld", "format": "c.ld       rd',uimm(rs1')", "description": "Load a 64-bit value from memory into register rd'.It computes an effective address by adding the zero-extended offset, scaled by 8, to the base address in register rs1'.", "implementation": "x[8+rd'] = M[x[8+rs1'] + uimm][63:0]", "expansion": "ld rd', offset[7:3](rs1')"},
    {"name": "c.fsd", "format": "c.fsd      rd',uimm(rs1')", "description": "Store a double-precision floating-point value in floating-point register rs2' to memory.It computes an effective address by adding the zeroextended offset, scaled by 8, to the base address in register rs1'.", "implementation": "M[x[8+rs1'] + uimm][63:0] = f[8+rs2']", "expansion": "fsd rs2',offset[7:3](rs1')"},
    {"name": "c.sw", "format": "c.sw       rd',uimm(rs1')", "description": "Store a 32-bit value in register rs2' to memory.It computes an effective address by adding the zero-extended offset, scaled by 4, to the base address in register rs1'.", "implementation": "M[x[8+rs1'] + uimm][31:0] = x[8+rs2']", "expansion": "sw rs2',offset[6:2](rs1')"},
    {"name": "c.fsw", "format": "c.fsw      rd',uimm(rs1')", "description": "Store a single-precision floating-point value in floatingpoint register rs2' to memory.It computes an effective address by adding the zero-extended offset, scaled by 4, to the base address in register rs1'.", "implementation": "M[x[8+rs1'] + uimm][31:0] = f[8+rs2']", "expansion": "fsw rs2', offset[6:2](rs1')"},
    {"name": "c.sd", "format": "c.sd       rd',uimm(rs1')", "description": "Store a 64-bit value in register rs2' to memory.It computes an effective address by adding the zero-extended offset, scaled by 8, to the base address in register rs1'.", "implementation": "M[x[8+rs1'] + uimm][63:0] = x[8+rs2']", "expansion": "sd rs2', offset[7:3](rs1')"},
    {"name": "c.nop", "format": "c.nop", "description": "Does not change any user-visible state, except for advancing the pc.", "implementation": "None", "expansion": "addi x0, x0, 0"},
    {"name": "c.addi", "format": "c.addi     rd,u[12:12]|u[6:2]", "description": "Add the non-zero sign-extended 6-bit immediate to the value in register rd then writes the result to rd.", "implementation": "x[rd] = x[rd] + sext(imm)", "expansion": "addi rd, rd, nzimm[5:0]"},
    {"name": "c.jal", "format": "c.jal offset", "description": "Jump to address and place return address in rd.", "implementation": "x[1] = pc+2; pc += sext(offset)", "expansion": "jal x1, offset[11:1]"},
    {"name": "c.addiw", "format": "c.addiw    rd,imm", "description": "Add the non-zero sign-extended 6-bit immediate to the value in register rd then produce 32-bit result, then sign-extends result to 64 bits.", "implementation": "x[rd] = sext((x[rd] + sext(imm))[31:0])", "expansion": "addiw rd,rd,imm[5:0]"},
    {"name": "c.li", "format": "c.li       rd,imm", "description": "Load the sign-extended 6-bit immediate, imm, into register rd.C.LI is only valid when rd!=x0.", "implementation": "x[rd] = sext(imm)", "expansion": "addi rd,x0,imm[5:0]"},
    {"name": "c.addi16sp", "format": "c.addi16sp imm", "description": "Add the non-zero sign-extended 6-bit immediate to the value in the stack pointer (sp=x2), where the immediate is scaled to represent multiples of 16 in the range (-512,496).", "implementation": "x[2] = x[2] + sext(imm)", "expansion": "addi x2,x2, nzimm[9:4]"},
    {"name": "c.lui", "format": "c.lui      rd,imm", "description": "", "implementation": "x[rd] = sext(imm[17:12] << 12)", "expansion": "lui rd,nzuimm[17:12]"},
    {"name": "c.srli", "format": "c.srli     rd',uimm", "description": "Perform a logical right shift of the value in register rd' then writes the result to rd'.The shift amount is encoded in the shamt field, where shamt[5] must be zero for RV32C.", "implementation": "x[8+rd'] = x[8+rd'] >>u uimm", "expansion": "srli rd',rd',shamt[5:0]"},
    {"name": "c.srai", "format": "c.srai     rd',uimm", "description": "Perform a arithmetic right shift of the value in register rd' then writes the result to rd'.The shift amount is encoded in the shamt field, where shamt[5] must be zero for RV32C.", "implementation": "x[8+rd'] = x[8+rd'] >>s uimm", "expansion": "srai rd',rd',shamt[5:0]"},
    {"name": "c.andi", "format": "c.andi     rd',imm", "description": "Compute the bitwise AND of of the value in register rd' and the sign-extended 6-bit immediate, then writes the result to rd'.", "implementation": "x[8+rd'] = x[8+rd'] & sext(imm)", "expansion": "andi rd',rd',imm[5:0]"},
    {"name": "c.sub", "format": "c.sub      rd',rs2'", "description": "Subtract the value in register rs2' from the value in register rd', then writes the result to register rd'.", "implementation": "x[8+rd'] = x[8+rd'] - x[8+rs2']", "expansion": "sub rd',rd',rs2'"},
    {"name": "c.xor", "format": "c.xor      rd',rs2'", "description": "Compute the bitwise XOR of the values in registers rd' and rs2', then writes the result to register rd'.", "implementation": "x[8+rd'] = x[8+rd'] ^ x[8+rs2']", "expansion": "xor rd',rd',rs2'"},
    {"name": "c.or", "format": "c.or       rd',rs2'", "description": "Compute the bitwise OR of the values in registers rd' and rs2', then writes the result to register rd'.", "implementation": "x[8+rd'] = x[8+rd'] | x[8+rs2']", "expansion": "or rd',rd',rs2"},
    {"name": "c.and", "format": "c.and      rd',rs2'", "description": "Compute the bitwise AND of the values in registers rd' and rs2', then writes the result to register rd'.", "implementation": "x[8+rd'] = x[8+rd'] & x[8+rs2']", "expansion": "and rd',rd',rs2'"},
    {"name": "c.subw", "format": "c.subw     rd',rs2'", "description": "Subtract the value in register rs2' from the value in register rd', then sign-extends the lower 32 bits of the difference before writing the result to register rd'.", "implementation": "x[8+rd'] = sext((x[8+rd'] - x[8+rs2'])[31:0])", "expansion": "subw rd',rd',rs2'"},
    {"name": "c.addw", "format": "c.addw     rd',rs2'", "description": "Add the value in register rs2' from the value in register rd', then sign-extends the lower 32 bits of the difference before writing the result to register rd'.", "implementation": "x[8+rd'] = sext((x[8+rd'] + x[8+rs2'])[31:0])", "expansion": "addw rd',rd',rs2'"},
    {"name": "c.j", "format": "c.j offset", "description": "Unconditional control transfer.", "implementation": "pc += sext(offset)", "expansion": "jal x0,offset[11:1]"},
    {"name": "c.beqz", "format": "c.beqz     rs1',offset", "description": "Take the branch if the value in register rs1' is zero.", "implementation": "if (x[8+rs1'] == 0) pc += sext(offset)", "expansion": "beq rs1',x0,offset[8:1]"},
    {"name": "c.bnez", "format": "c.bnez     rs1',offset", "description": "Take the branch if the value in register rs1' is not zero.", "implementation": "if (x[8+rs1'] != 0) pc += sext(offset)", "expansion": "bne rs1',x0,offset[8:1]"},
    {"name": "c.slli", "format": "c.slli     rd,uimm", "description": "Perform a logical left shift of the value in register rd then writes the result to rd.The shift amount is encoded in the shamt field, where shamt[5] must be zero for RV32C.", "implementation": "x[rd] = x[rd] << uimm", "expansion": "slli rd,rd,shamt[5:0]"},
    {"name": "c.fldsp", "format": "c.fldsp    rd,uimm(x2)", "description": "Load a double-precision floating-point value from memory into floating-point register rd.It computes its effective address by adding the zero-extended offset, scaled by 8, to the stack pointer, x2.", "implementation": "f[rd] = M[x[2] + uimm][63:0]", "expansion": "fld rd,offset[8:3](x2)"},
    {"name": "c.lwsp", "format": "c.lwsp     rd,uimm(x2)", "description": "Load a 32-bit value from memory into register rd. It computes an effective address by adding the zero-extended offset, scaled by 4, to the stack pointer, x2.", "implementation": "x[rd] = sext(M[x[2] + uimm][31:0])", "expansion": "lw rd,offset[7:2](x2)"},
    {"name": "c.flwsp", "format": "c.flwsp    rd,uimm(x2)", "description": "Load a single-precision floating-point value from memory into floating-point register rd.It computes its effective address by adding the zero-extended offset, scaled by 4, to the stack pointer, x2.", "implementation": "f[rd] = M[x[2] + uimm][31:0]", "expansion": "flw rd,offset[7:2](x2)"},
    {"name": "c.ldsp", "format": "c.ldsp     rd,uimm(x2)", "description": "Load a 64-bit value from memory into register rd.It computes its effective address by adding the zero-extended offset, scaled by 8, to the stack pointer, x2.", "implementation": "x[rd] = M[x[2] + uimm][63:0]", "expansion": "ld rd,offset[8:3](x2)"},
    {"name": "c.jr", "format": "c.jr rs1", "description": "Performs an unconditional control transfer to the address in register rs1.", "implementation": "pc = x[rs1]", "expansion": "jalr x0,rs1,0"},
    {"name": "c.mv", "format": "c.mv       rd,rs2", "description": "Copy the value in register rs2 into register rd.", "implementation": "x[rd] = x[rs2]", "expansion": "add rd, x0, rs2"},
    {"name": "c.ebreak", "format": "c.ebreak", "description": "Cause control to be transferred back to the debugging environment.", "implementation": "RaiseException(Breakpoint)", "expansion": "ebreak"},
    {"name": "c.jalr", "format": "c.jalr     rd", "description": "Jump to address and place return address in rd.", "implementation": "t = pc+2; pc = x[rs1]; x[1] = t", "expansion": "jalr x1,rs1,0"},
    {"name": "c.add", "format": "c.add      rd,rs2", "description": "Add the values in registers rd and rs2 and writes the result to register rd.", "implementation": "x[rd] = x[rd] + x[rs2]", "expansion": "add rd,rd,rs2"},
    {"name": "c.fsdsp", "format": "c.fsdsp rs2,uimm(x2)", "description": "Store a double-precision floating-point value in floating-point register rs2 to memory.It computes an effective address by adding the zeroextended offset, scaled by 8, to the stack pointer, x2.", "implementation": "M[x[2] + uimm][63:0] = f[rs2]", "expansion": "fsd rs2,offset[8:3](x2)"},
    {"name": "c.swsp", "format": "c.swsp rs2,uimm(x2)", "description": "Store a 32-bit value in register rs2 to memory.It computes an effective address by adding the zero-extended offset, scaled by 4, to the stack pointer, x2.", "implementation": "M[x[2] + uimm][31:0] = x[rs2]", "expansion": "sw rs2,offset[7:2](x2)"},
    {"name": "c.fswsp", "format": "c.fswsp rs2,uimm(rs2)", "description": "Store a single-precision floating-point value in floating-point register rs2 to memory.It computes an effective address by adding the zero-extended offset, scaled by 4, to the stack pointer, x2.", "implementation": "M[x[2] + uimm][31:0] = f[rs2]", "expansion": "fsw rs2,offset[7:2](x2)"},
    {"name": "c.sdsp", "format": "c.sdsp rs2,uimm(x2)", "description": "Store a 64-bit value in register rs2 to memory.It computes an effective address by adding the zero-extended offset, scaled by 8, to the stack pointer, x2.", "implementation": "M[x[2] + uimm][63:0] = x[rs2]", "expansion": "sd rs2,offset[8:3](x2)"},
    {"name": "fmadd.s", "format": "fmadd.s    rd,rs1,rs2,rs3", "description": "Perform single-precision fused multiply addition.", "implementation": "f[rd] = f[rs1]\u00d7f[rs2]+f[rs3]"},
    {"name": "fmsub.s", "format": "fmsub.s    rd,rs1,rs2,rs3", "description": "Perform single-precision fused multiply addition.", "implementation": "f[rd] = f[rs1]\u00d7f[rs2]-f[rs3]"},
    {"name": "fnmsub.s", "format": "fnmsub.s   rd,rs1,rs2,rs3", "description": "Perform single-precision fused multiply addition.", "implementation": "f[rd] = -f[rs1]\u00d7f[rs2]+f[rs3]"},
    {"name": "fnmadd.s", "format": "fnmadd.s   rd,rs1,rs2,rs3", "description": "Perform single-precision fused multiply addition.", "implementation": "f[rd] = -f[rs1]\u00d7f[rs2]-f[rs3]"},
    {"name": "fadd.s", "format": "fadd.s     rd,rs1,rs2", "description": "Perform single-precision floating-point addition.", "implementation": "f[rd] = f[rs1] + f[rs2]"},
    {"name": "fsub.s", "format": "fsub.s     rd,rs1,rs2", "description": "Perform single-precision floating-point substraction.", "implementation": "f[rd] = f[rs1] - f[rs2]"},
    {"name": "fmul.s", "format": "fmul.s     rd,rs1,rs2", "description": "Perform single-precision floating-point multiplication.", "implementation": "f[rd] = f[rs1] \u00d7 f[rs2]"},
    {"name": "fdiv.s", "format": "fdiv.s     rd,rs1,rs2", "description": "Perform single-precision floating-point division.", "implementation": "f[rd] = f[rs1] / f[rs2]"},
    {"name": "fsqrt.s", "format": "fsqrt.s    rd,rs1", "description": "Perform single-precision square root.", "implementation": "f[rd] = sqrt(f[rs1])"},
    {"name": "fsgnj.s", "format": "fsgnj.s    rd,rs1,rs2", "description": "Produce a result that takes all bits except the sign bit from rs1.The result\u2019s sign bit is rs2\u2019s sign bit.", "implementation": "f[rd] = {f[rs2][31], f[rs1][30:0"},
    {"name": "fsgnjn.s", "format": "fsgnjn.s   rd,rs1,rs2", "description": "Produce a result that takes all bits except the sign bit from rs1.The result\u2019s sign bit is opposite of rs2\u2019s sign bit.", "implementation": "f[rd] = {~f[rs2][31], f[rs1][30:0"},
    {"name": "fsgnjx.s", "format": "fsgnjx.s   rd,rs1,rs2", "description": "Produce a result that takes all bits except the sign bit from rs1.The result\u2019s sign bit is XOR of sign bit of rs1 and rs2.", "implementation": "f[rd] = {f[rs1][31] ^ f[rs2][31], f[rs1][30:0"},
    {"name": "fmin.s", "format": "fmin.s     rd,rs1,rs2", "description": "Write the smaller of single precision data in rs1 and rs2 to rd.", "implementation": "f[rd] = min(f[rs1], f[rs2])"},
    {"name": "fmax.s", "format": "fmax.s     rd,rs1,rs2", "description": "Write the larger of single precision data in rs1 and rs2 to rd.", "implementation": "f[rd] = max(f[rs1], f[rs2])"},
    {"name": "fcvt.w.s", "format": "fcvt.w.s   rd,rs1", "description": "Convert a floating-point number in floating-point register rs1 to a signed 32-bit in integer register rd.", "implementation": "x[rd] = sext(s32_{f32}(f[rs1]))"},
    {"name": "fcvt.wu.s", "format": "fcvt.wu.s  rd,rs1", "description": "Convert a floating-point number in floating-point register rs1 to a signed 32-bit in unsigned integer register rd.", "implementation": "x[rd] = sext(u32_{f32}(f[rs1]))"},
    {"name": "fmv.x.w", "format": "fmv.x.w    rd,rs1", "description": "Move the single-precision value in floating-point register rs1 represented in IEEE 754-2008 encoding to the lower 32 bits of integer register rd.", "implementation": "x[rd] = sext(f[rs1][31:0])"},
    {"name": "feq.s", "format": "feq.s      rd,rs1,rs2", "description": "Performs a quiet equal comparison between floating-point registers rs1 and rs2 and record the Boolean result in integer register rd.Only signaling NaN inputs cause an Invalid Operation exception.The result is 0 if either operand is NaN.", "implementation": "x[rd] = f[rs1] == f[rs2]"},
    {"name": "flt.s", "format": "flt.s      rd,rs1,rs2", "description": "Performs a quiet less comparison between floating-point registers rs1 and rs2 and record the Boolean result in integer register rd.Only signaling NaN inputs cause an Invalid Operation exception.The result is 0 if either operand is NaN.", "implementation": "x[rd] = f[rs1] < f[rs2]"},
    {"name": "fle.s", "format": "fle.s      rd,rs1,rs2", "description": "Performs a quiet less or equal comparison between floating-point registers rs1 and rs2 and record the Boolean result in integer register rd.Only signaling NaN inputs cause an Invalid Operation exception.The result is 0 if either operand is NaN.", "implementation": "x[rd] = f[rs1] <= f[rs2]"},
    {"name": "fclass.s", "format": "fclass.s   rd,rs1", "description": "Examines the value in floating-point register rs1 and writes to integer register rd a 10-bit mask that indicates the class of the floating-point number.The format of the mask is described in [classify table]_.The corresponding bit in rd will be set if the property is true and clear otherwise.All other bits in rd are cleared. Note that exactly one bit in rd will be set.", "implementation": "x[rd] = classifys(f[rs1])"},
    {"name": "fcvt.s.w", "format": "fcvt.s.w   rd,rs1", "description": "Converts a 32-bit signed integer, in integer register rs1 into a floating-point number in floating-point register rd.", "implementation": "f[rd] = f32_{s32}(x[rs1])"},
    {"name": "fcvt.s.wu", "format": "fcvt.s.wu  rd,rs1", "description": "Converts a 32-bit unsigned integer, in integer register rs1 into a floating-point number in floating-point register rd.", "implementation": "f[rd] = f32_{u32}(x[rs1])"},
    {"name": "fmv.w.x", "format": "fmv.w.x    rd,rs1", "description": "Move the single-precision value encoded in IEEE 754-2008 standard encoding from the lower 32 bits of integer register rs1 to the floating-point register rd.", "implementation": "f[rd] = x[rs1][31:0]"},
    {"name": "fmadd.d", "format": "fmadd.d    rd,rs1,rs2,rs3", "description": "Perform single-precision fused multiply addition.", "implementation": "f[rd] = f[rs1]\u00d7f[rs2]+f[rs3]"},
    {"name": "fmsub.d", "format": "fmsub.d    rd,rs1,rs2,rs3", "description": "Perform single-precision fused multiply addition.", "implementation": "f[rd] = f[rs1]\u00d7f[rs2]-f[rs3]"},
    {"name": "fnmsub.d", "format": "fnmsub.d   rd,rs1,rs2,rs3", "description": "Perform single-precision fused multiply addition.", "implementation": "f[rd] = -f[rs1]\u00d7f[rs2+f[rs3]"},
    {"name": "fnmadd.d", "format": "fnmadd.d   rd,rs1,rs2,rs3", "description": "Perform single-precision fused multiply addition.", "implementation": "f[rd] = -f[rs1]\u00d7f[rs2]-f[rs3]"},
    {"name": "fadd.d", "format": "fadd.d     rd,rs1,rs2", "description": "Perform single-precision floating-point addition.", "implementation": "f[rd] = f[rs1] + f[rs2]"},
    {"name": "fsub.d", "format": "fsub.d     rd,rs1,rs2", "description": "Perform single-precision floating-point subtraction.", "implementation": "f[rd] = f[rs1] - f[rs2]"},
    {"name": "fmul.d", "format": "fmul.d     rd,rs1,rs2", "description": "Perform single-precision floating-point multiplication.", "implementation": "f[rd] = f[rs1] \u00d7 f[rs2]"},
    {"name": "fdiv.d", "format": "fdiv.d     rd,rs1,rs2", "description": "Perform single-precision floating-point division.", "implementation": "f[rd] = f[rs1] / f[rs2]"},
    {"name": "fsqrt.d", "format": "fsqrt.d    rd,rs1", "description": "Perform single-precision square root.", "implementation": "f[rd] = sqrt(f[rs1])"},
    {"name": "fsgnj.d", "format": "fsgnj.d    rd,rs1,rs2", "description": "Produce a result that takes all bits except the sign bit from rs1.The result\u2019s sign bit is rs2\u2019s sign bit.", "implementation": "f[rd] = {f[rs2][63], f[rs1][62:0"},
    {"name": "fsgnjn.d", "format": "fsgnjn.d   rd,rs1,rs2", "description": "Produce a result that takes all bits except the sign bit from rs1.The result\u2019s sign bit is opposite of rs2\u2019s sign bit.", "implementation": "f[rd] = {~f[rs2][63], f[rs1][62:0"},
    {"name": "fsgnjx.d", "format": "fsgnjx.d   rd,rs1,rs2", "description": "Produce a result that takes all bits except the sign bit from rs1.The result\u2019s sign bit is XOR of sign bit of rs1 and rs2.", "implementation": "f[rd] = {f[rs1][63] ^ f[rs2][63], f[rs1][62:0"},
    {"name": "fmin.d", "format": "fmin.d     rd,rs1,rs2", "description": "Write the smaller of single precision data in rs1 and rs2 to rd.", "implementation": "f[rd] = min(f[rs1], f[rs2])"},
    {"name": "fmax.d", "format": "fmax.d     rd,rs1,rs2", "description": "Write the larger of single precision data in rs1 and rs2 to rd.", "implementation": "f[rd] = max(f[rs1], f[rs2])"},
    {"name": "fcvt.s.d", "format": "fcvt.s.d   rd,rs1", "description": "Converts double floating-point register in rs1 into a floating-point number in floating-point register rd.", "implementation": "f[rd] = f32_{f64}(f[rs1])"},
    {"name": "fcvt.d.s", "format": "fcvt.d.s   rd,rs1", "description": "Converts single floating-point register in rs1 into a double floating-point number in floating-point register rd.", "implementation": "f[rd] = f64_{f32}(f[rs1])"},
    {"name": "feq.d", "format": "feq.d      rd,rs1,rs2", "description": "Performs a quiet equal comparison between floating-point registers rs1 and rs2 and record the Boolean result in integer register rd.Only signaling NaN inputs cause an Invalid Operation exception.The result is 0 if either operand is NaN.", "implementation": "x[rd] = f[rs1] == f[rs2]"},
    {"name": "flt.d", "format": "flt.d      rd,rs1,rs2", "description": "Performs a quiet less comparison between floating-point registers rs1 and rs2 and record the Boolean result in integer register rd.Only signaling NaN inputs cause an Invalid Operation exception.The result is 0 if either operand is NaN.", "implementation": "x[rd] = f[rs1] < f[rs2]"},
    {"name": "fle.d", "format": "fle.d      rd,rs1,rs2", "description": "Performs a quiet less or equal comparison between floating-point registers rs1 and rs2 and record the Boolean result in integer register rd.Only signaling NaN inputs cause an Invalid Operation exception.The result is 0 if either operand is NaN.", "implementation": "x[rd] = f[rs1] <= f[rs2]"},
    {"name": "fclass.d", "format": "fclass.d   rd,rs1", "description": "Examines the value in floating-point register rs1 and writes to integer register rd a 10-bit mask that indicates the class of the floating-point number.The format of the mask is described in table [classify table]_.The corresponding bit in rd will be set if the property is true and clear otherwise.All other bits in rd are cleared. Note that exactly one bit in rd will be set.", "implementation": "x[rd] = classifys(f[rs1])"},
    {"name": "fcvt.w.d", "format": "fcvt.w.d   rd,rs1", "description": "Converts a double-precision floating-point number in floating-point register rs1 to a signed 32-bit integer, in integer register rd.", "implementation": "x[rd] = sext(s32_{f64}(f[rs1]))"},
    {"name": "fcvt.wu.d", "format": "fcvt.wu.d  rd,rs1", "description": "Converts a double-precision floating-point number in floating-point register rs1 to a unsigned 32-bit integer, in integer register rd.", "implementation": "x[rd] = sext(u32f64(f[rs1]))"},
    {"name": "fcvt.d.w", "format": "fcvt.d.w   rd,rs1", "description": "Converts a 32-bit signed integer, in integer register rs1 into a double-precision floating-point number in floating-point register rd.", "implementation": "x[rd] = sext(s32_{f64}(f[rs1]))"},
    {"name": "fcvt.d.wu", "format": "fcvt.d.wu  rd,rs1", "description": "Converts a 32-bit unsigned integer, in integer register rs1 into a double-precision floating-point number in floating-point register rd.", "implementation": "f[rd] = f64_{u32}(x[rs1])"},
    {"name": "flw", "format": "flw        rd,offset(rs1)", "description": "Load a single-precision floating-point value from memory into floating-point register rd.", "implementation": "f[rd] = M[x[rs1] + sext(offset)][31:0]"},
    {"name": "fsw", "format": "fsw        rs2,offset(rs1)", "description": "Store a single-precision value from floating-point register rs2 to memory.", "implementation": "M[x[rs1] + sext(offset)] = f[rs2][31:0]"},
    {"name": "fld", "format": "fld        rd,rs1,offset", "description": "Load a double-precision floating-point value from memory into floating-point register rd.", "implementation": "f[rd] = M[x[rs1] + sext(offset)][63:0]"},
    {"name": "fsd", "format": "fsd        rs2,offset(rs1)", "description": "Store a double-precision value from the floating-point registers to memory.", "implementation": "M[x[rs1] + sext(offset)] = f[rs2][63:0]"},
    {"name":"lui", "sdescription":"load upper immediate.", "format":"lui        rd,imm", "description":"Build 32-bit constants and uses the U-type format. LUI places the U-immediate value in the top 20 bits of the destination register rd, filling in the lowest 12 bits with zeros.", "implementation":"x[rd] = sext(immediate[31:12] << 12)"},
    {"name":"auipc", "sdescription":"add upper immediate to pc", "format":"auipc      rd,imm", "description":"Build pc-relative addresses and uses the U-type format. AUIPC forms a 32-bit offset from the 20-bit U-immediate, filling in the lowest 12 bits with zeros, adds this offset to the pc, then places the result in register rd.", "implementation":"x[rd] = pc + sext(immediate[31:12] << 12)"},
    {"name":"addi", "sdescription":"add immediate", "format":"addi       rd,rs1,imm", "description":"Adds the sign-extended 12-bit immediate to register rs1. Arithmetic overflow is ignored and the result is simply the low XLEN bits of the result. ADDI rd, rs1, 0 is used to implement the MV rd, rs1 assembler pseudo-instruction.", "implementation":"x[rd] = x[rs1] + sext(immediate)"},
    {"name":"slti", "sdescription":"set less than immediate", "format":"slti       rd,rs1,imm", "description":"Place the value 1 in register rd if register rs1 is less than the signextended immediate when both are treated as signed numbers, else 0 is written to rd.", "implementation":"x[rd] = x[rs1] <s sext(immediate)"},
    {"name":"sltiu", "format":"sltiu      rd,rs1,imm", "description":"Place the value 1 in register rd if register rs1 is less than the immediate when both are treated as unsigned numbers, else 0 is written to rd.", "implementation":"x[rd] = x[rs1] <u sext(immediate)"},
    {"name":"xori", "format":"xori       rd,rs1,imm", "description":"Performs bitwise XOR on register rs1 and the sign-extended 12-bit immediate and place the result in rd", "implementation":"x[rd] = x[rs1] ^ sext(immediate)"},
    {"name":"ori", "format":"ori        rd,rs1,imm", "description":"Performs bitwise OR on register rs1 and the sign-extended 12-bit immediate and place the result in rd", "implementation":"x[rd] = x[rs1] | sext(immediate)"},
    {"name":"andi", "format":"andi       rd,rs1,imm", "description":"Performs bitwise AND on register rs1 and the sign-extended 12-bit immediate and place the result in rd", "implementation":"x[rd] = x[rs1] & sext(immediate)"},
    {"name":"slli", "format":"slli       rd,rs1,shamt", "description":"Performs logical left shift on the value in register rs1 by the shift amount held in the lower 5 bits of the immediate", "implementation":"x[rd] = x[rs1] << shamt"},
    {"name":"srli", "format":"srli       rd,rs1,shamt", "description":"Performs logical right shift on the value in register rs1 by the shift amount held in the lower 5 bits of the immediate", "implementation":"x[rd] = x[rs1] >>u shamt"},
    {"name":"srai", "format":"srai       rd,rs1,shamt", "description":"Performs arithmetic right shift on the value in register rs1 by the shift amount held in the lower 5 bits of the immediate", "implementation":"x[rd] = x[rs1] >>s shamt"},
    {"name":"add", "format":"add        rd,rs1,rs2", "description":"Adds the registers rs1 and rs2 and stores the result in rd.", "implementation":"x[rd] = x[rs1] + x[rs2]"},
    {"name":"sub", "format":"sub        rd,rs1,rs2", "description":"Subs the register rs2 from rs1 and stores the result in rd.", "implementation":"x[rd] = x[rs1] - x[rs2]"},
    {"name":"sll", "format":"sll        rd,rs1,rs2", "description":"Performs logical left shift on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2.", "implementation":"x[rd] = x[rs1] << x[rs2]"},
    {"name":"slt", "format":"slt        rd,rs1,rs2", "description":"Place the value 1 in register rd if register rs1 is less than register rs2 when both are treated as signed numbers, else 0 is written to rd.", "implementation":"x[rd] = x[rs1] <s x[rs2]"},
    {"name":"sltu", "format":"sltu       rd,rs1,rs2", "description":"Place the value 1 in register rd if register rs1 is less than register rs2 when both are treated as unsigned numbers, else 0 is written to rd.", "implementation":"x[rd] = x[rs1] <u x[rs2]"},
    {"name":"xor", "format":"xor        rd,rs1,rs2", "description":"Performs bitwise XOR on registers rs1 and rs2 and place the result in rd", "implementation":"x[rd] = x[rs1] ^ x[rs2]"},
    {"name":"srl", "format":"srl        rd,rs1,rs2", "description":"Logical right shift on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2", "implementation":"x[rd] = x[rs1] >>u x[rs2]"},
    {"name":"sra", "format":"sra        rd,rs1,rs2", "description":"Performs arithmetic right shift on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2", "implementation":"x[rd] = x[rs1] >>s x[rs2]"},
    {"name":"or", "format":"or         rd,rs1,rs2", "description":"Performs bitwise OR on registers rs1 and rs2 and place the result in rd", "implementation":"x[rd] = x[rs1] | x[rs2]"},
    {"name":"and", "format":"and        rd,rs1,rs2", "description":"Performs bitwise AND on registers rs1 and rs2 and place the result in rd", "implementation":"x[rd] = x[rs1] & x[rs2]"},
    {"name":"fence", "format":"fence pred, succ", "description":"Used to order device I/O and memory accesses as viewed by other RISC-V harts and external devices or coprocessors.", "implementation":"Fence(pred, succ)", "sdescription":"fence."},
    {"name":"i", "format":"fence.i", "description":"Provides explicit synchronization between writes to instruction memory and instruction fetches on the same hart.", "implementation":"Fence(Store, Fetch)"
    },
    {"name":"csrrw", "sdescription":"atomic read/write CSR.", "format":"csrrw      rd,offset,rs1", "description":"Atomically swaps values in the CSRs and integer registers.", "implementation":"t = CSRs[csr]; CSRs[csr] = x[rs1]; x[rd] = t"},
    {"name":"csrrs", "sdescription":"atomic read and set bits in CSR.", "format":"csrrs      rd,offset,rs1", "description":"Reads the value of the CSR, zero-extends the value to XLEN bits, and writes it to integer register rd.", "implementation":"t = CSRs[csr]; CSRs[csr] = t | x[rs1]; x[rd] = t"},
    {"name":"csrrc", "sdescription":"atomic read and clear bits in CSR.", "format":"csrrc      rd,offset,rs1", "description":"Reads the value of the CSR, zero-extends the value to XLEN bits, and writes it to integer register rd.", "implementation":"t = CSRs[csr]; CSRs[csr] = t &∼x[rs1]; x[rd] = t"},
    {"name":"csrrwi", "format":"csrrwi     rd,offset,uimm", "description":"Update the CSR using an XLEN-bit value obtained by zero-extending a 5-bit unsigned immediate (uimm[4:0]) field encoded in the rs1 field.", "implementation":"x[rd] = CSRs[csr]; CSRs[csr] = zimm"},
    {"name":"csrrsi", "format":"csrrsi     rd,offset,uimm", "description":"Set CSR bit using an XLEN-bit value obtained by zero-extending a 5-bit unsigned immediate (uimm[4:0]) field encoded in the rs1 field.", "implementation":"t = CSRs[csr]; CSRs[csr] = t | zimm; x[rd] = t"},
    {"name":"csrrci", "format":"csrrci     rd,offset,uimm", "description":"Clear CSR bit using an XLEN-bit value obtained by zero-extending a 5-bit unsigned immediate (uimm[4:0]) field encoded in the rs1 field.", "implementation":"t = CSRs[csr]; CSRs[csr] = t &∼zimm; x[rd] = t"},
    {"name":"ecall", "format":"ecall", "description":"Make a request to the supporting execution environment.", "implementation":"RaiseException(EnvironmentCall)"},
    {"name":"ebreak", "format":"ebreak", "description":"Used by debuggers to cause control to be transferred back to a debugging environment.", "implementation":"RaiseException(Breakpoint)"},
    {"name":"uret", "format":"uret", "description":"Return from traps in U-mode, and URET copies UPIE into UIE, then sets UPIE.", "implementation":"ExceptionReturn(User)"},
    {"name":"sret", "format":"sret", "description":"Return from traps in S-mode, and SRET copies SPIE into SIE, then sets SPIE.", "implementation":"ExceptionReturn(User)"},
    {"name":"mret", "format":"mret", "description":"Return from traps in M-mode, and MRET copies MPIE into MIE, then sets MPIE.", "implementation":"ExceptionReturn(Machine)"},
    {"name":"wfi", "sdescription":"wait for interrupt.", "format":"wfi", "description":"Provides a hint to the implementation that the current hart can be stalled until an interrupt   might need servicing.", "implementation":"while (noInterruptsPending) idle", "sdescription":"sfence."
    },
    {"name":"vma", "format":"sfence.vma rs1,rs2", "description":"Guarantees that any previous stores already visible to the current RISC-V hart are ordered before all subsequent implicit references from that hart to the memory-management data structures.", "implementation":"Fence(Store, AddressTranslation)"},
    {"name":"lb", "format":"lb         rd,offset(rs1)", "description":"Loads a 8-bit value from memory and sign-extends this to XLEN bits before storing it in register rd.", "implementation":"x[rd] = sext(M[x[rs1] + sext(offset)][7:0])"},
    {"name":"lh", "format":"lh         rd,offset(rs1)", "description":"Loads a 16-bit value from memory and sign-extends this to XLEN bits before storing it in register rd.", "implementation":"x[rd] = sext(M[x[rs1] + sext(offset)][15:0])"},
    {"name":"lw", "format":"lw         rd,offset(rs1)", "description":"Loads a 32-bit value from memory and sign-extends this to XLEN bits before storing it in register rd.", "implementation":"x[rd] = sext(M[x[rs1] + sext(offset)][31:0])"},
    {"name":"lbu", "format":"lbu        rd,offset(rs1)", "description":"Loads a 8-bit value from memory and zero-extends this to XLEN bits before storing it in register rd.", "implementation":"x[rd] = M[x[rs1] + sext(offset)][7:0]"},
    {"name":"lhu", "format":"lhu        rd,offset(rs1)", "description":"Loads a 16-bit value from memory and zero-extends this to XLEN bits before storing it in register rd.", "implementation":"x[rd] = M[x[rs1] + sext(offset)][15:0]"},
    {"name":"sb", "format":"sb         rs2,offset(rs1)", "description":"Store 8-bit, values from the low bits of register rs2 to memory.", "implementation":"M[x[rs1] + sext(offset)] = x[rs2][7:0]"},
    {"name":"sh", "format":"sh         rs2,offset(rs1)", "description":"Store 16-bit, values from the low bits of register rs2 to memory.", "implementation":"M[x[rs1] + sext(offset)] = x[rs2][15:0]"},
    {"name":"sw", "format":"sw         rs2,offset(rs1)", "description":"Store 32-bit, values from the low bits of register rs2 to memory.", "implementation":"M[x[rs1] + sext(offset)] = x[rs2][31:0]"},
    {"name":"jal", "format":"jal        rd,offset", "description":"Jump to address and place return address in rd.", "implementation":"x[rd] = pc+4; pc += sext(offset)"},
    {"name":"jalr", "format":"jalr       rd,rs1,offset", "description":"Jump to address and place return address in rd.", "implementation":"t =pc+4; pc=(x[rs1]+sext(offset))&∼1; x[rd]=t"},
    {"name":"beq", "format":"beq        rs1,rs2,offset", "description":"Take the branch if registers rs1 and rs2 are equal.", "implementation":"if (x[rs1] == x[rs2]) pc += sext(offset)"},
    {"name":"bne", "format":"bne        rs1,rs2,offset", "description":"Take the branch if registers rs1 and rs2 are not equal.", "implementation":"if (x[rs1] != x[rs2]) pc += sext(offset)"},
    {"name":"blt", "format":"blt        rs1,rs2,offset", "description":"Take the branch if registers rs1 is less than rs2, using signed comparison.", "implementation":"if (x[rs1] <s x[rs2]) pc += sext(offset)"},
    {"name":"bge", "format":"bge        rs1,rs2,offset", "description":"Take the branch if registers rs1 is greater than or equal to rs2, using signed comparison.", "implementation":"if (x[rs1] >=s x[rs2]) pc += sext(offset)"},
    {"name":"bltu", "format":"bltu       rs1,rs2,offset", "description":"Take the branch if registers rs1 is less than rs2, using unsigned comparison.", "implementation":"if (x[rs1] <u x[rs2]) pc += sext(offset)"},
    {"name":"bgeu", "format":"bgeu       rs1,rs2,offset", "description":"Take the branch if registers rs1 is greater than or equal to rs2, using unsigned comparison.", "implementation":"if (x[rs1] >=u x[rs2]) pc += sext(offset)"},
    {"name": "mul", "format": "mul        rd,rs1,rs2", "description": "performs an XLEN-bit ", "implementation": "x[rd] = x[rs1] \u00d7 x[rs2]"},
    {"name": "mulh", "format": "mulh       rd,rs1,rs2", "description": "performs an XLEN-bit ", "implementation": "x[rd] = (x[rs1] s\u00d7s x[rs2]) >>s XLEN"},
    {"name": "mulhsu", "format": "mulhsu     rd,rs1,rs2", "description": "performs an XLEN-bit ", "implementation": "x[rd] = (x[rs1] s "},
    {"name": "mulhu", "format": "mulhu      rd,rs1,rs2", "description": "performs an XLEN-bit ", "implementation": "x[rd] = (x[rs1] u "},
    {"name": "div", "format": "div        rd,rs1,rs2", "description": "perform an XLEN bits by XLEN bits signed integer division of rs1 by rs2, rounding towards zero.", "implementation": "x[rd] = x[rs1] /s x[rs2]"},
    {"name": "divu", "format": "divu       rd,rs1,rs2", "description": "perform an XLEN bits by XLEN bits unsigned integer division of rs1 by rs2, rounding towards zero.", "implementation": "x[rd] = x[rs1] /u x[rs2]"},
    {"name": "rem", "format": "rem        rd,rs1,rs2", "description": "perform an XLEN bits by XLEN bits signed integer reminder of rs1 by rs2.", "implementation": "x[rd] = x[rs1] %s x[rs2]"},
    {"name": "remu", "format": "remu       rd,rs1,rs2", "description": "perform an XLEN bits by XLEN bits unsigned integer reminder of rs1 by rs2.", "implementation": "x[rd] = x[rs1] %u x[rs2]"}
]
}
